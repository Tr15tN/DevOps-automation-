# GitLab CI/CD Pipeline for Automation Alchemy
# Phase 3: CI/CD Pipeline + Phase 4: Testing Integration

stages:
  - validate
  - test
  - build
  - security
  - deploy
  - integration
  - healthcheck

variables:
  # GCP Configuration
  GCP_PROJECT_ID: "automation-alchemy"
  GCP_REGION: "europe-north1"
  CONTAINER_REGISTRY: "europe-north1-docker.pkg.dev"
  IMAGE_NAME: "app-server"
  
  # Docker Configuration
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  
  # Application Configuration
  APP_DIR: "/opt/app"

# =============================================================================
# VALIDATE STAGE
# =============================================================================

terraform:validate:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache curl unzip
    - |
      TERRAFORM_VERSION=1.5.0
      wget -q https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
      unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip -d /tmp
      mv /tmp/terraform /usr/local/bin/
      chmod +x /usr/local/bin/terraform
      rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
  script:
    - |
      cd terraform
      terraform init -backend=false
      terraform validate
      terraform fmt -check
  only:
    - merge_requests
    - master
    - develop

ansible:lint:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache python3 py3-pip
    - python3 -m venv /tmp/venv
    - . /tmp/venv/bin/activate
    - pip install ansible-lint
  script:
    - . /tmp/venv/bin/activate
    - ansible-lint ansible/playbooks/*.yml || true
  only:
    - merge_requests
    - master
    - develop
  allow_failure: true
  # Note: allow_failure is true because linting is optional - it helps catch issues but shouldn't block the pipeline

# =============================================================================
# TEST STAGE (Phase 4: Code Quality)
# =============================================================================

test:code-quality:
  stage: test
  image: alpine:latest
  before_script:
    - apk add --no-cache bash shellcheck nodejs npm curl
    - npm install -g eslint
  script:
    - chmod +x tests/code-quality.sh
    - tests/code-quality.sh
  only:
    - merge_requests
    - master
    - develop
  allow_failure: false

# =============================================================================
# BUILD STAGE
# =============================================================================

docker:build:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  before_script:
    - apk add --no-cache curl python3 py3-pip bash
    - curl https://sdk.cloud.google.com | bash
    - export PATH=$PATH:/root/google-cloud-sdk/bin
    - |
      echo "$GCP_SERVICE_ACCOUNT_KEY" | base64 -d > /tmp/gcp-key.json
      if [ ! -s /tmp/gcp-key.json ]; then
        echo "ERROR: Failed to decode GCP_SERVICE_ACCOUNT_KEY"
        echo "Key length: ${#GCP_SERVICE_ACCOUNT_KEY}"
        exit 1
      fi
      gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
    - gcloud config set project $GCP_PROJECT_ID
    - gcloud auth configure-docker $CONTAINER_REGISTRY
  script:
    - |
      export IMAGE_TAG="${CI_COMMIT_SHORT_SHA}"
      export IMAGE_FULL="${CONTAINER_REGISTRY}/${GCP_PROJECT_ID}/${IMAGE_NAME}/${IMAGE_NAME}:${IMAGE_TAG}"
      export IMAGE_LATEST="${CONTAINER_REGISTRY}/${GCP_PROJECT_ID}/${IMAGE_NAME}/${IMAGE_NAME}:latest"
      echo "Building Docker image: ${IMAGE_FULL}"
      cd docker/app-server
      docker build -t ${IMAGE_FULL} -t ${IMAGE_LATEST} .
      echo "Pushing image to GCP Container Registry..."
      docker push ${IMAGE_FULL}
      docker push ${IMAGE_LATEST}
      echo "${IMAGE_FULL}" > docker-image.txt
      cd ../..
      cp docker/app-server/docker-image.txt docker-image.txt
  after_script:
    - rm -f /tmp/gcp-key.json
  artifacts:
    paths:
      - docker-image.txt
    expire_in: 1 hour
  only:
    - main
    - master
    - develop
    - tags

# =============================================================================
# SECURITY STAGE (Phase 4: Security Scanning)
# =============================================================================

security:container-scan:
  stage: security
  image: alpine:latest
  before_script:
    - apk add --no-cache bash curl python3 py3-pip
    - | 
      # Install Trivy for Alpine Linux
      TRIVY_VERSION=$(curl -s https://api.github.com/repos/aquasecurity/trivy/releases/latest | grep tag_name | cut -d '"' -f 4 | sed 's/v//')
      wget -q https://github.com/aquasecurity/trivy/releases/download/v${TRIVY_VERSION}/trivy_${TRIVY_VERSION}_Linux-64bit.tar.gz
      tar -xzf trivy_${TRIVY_VERSION}_Linux-64bit.tar.gz
      mv trivy /usr/local/bin/
      chmod +x /usr/local/bin/trivy
      rm trivy_${TRIVY_VERSION}_Linux-64bit.tar.gz
    - |
      # Install gcloud SDK if we need to authenticate for image scanning
      if [ -n "$GCP_SERVICE_ACCOUNT_KEY" ]; then
        curl https://sdk.cloud.google.com | bash || true
        export PATH=$PATH:/root/google-cloud-sdk/bin
      fi
  script:
    - |
      export IMAGE_FULL=$(cat docker-image.txt || echo "${CONTAINER_REGISTRY}/${GCP_PROJECT_ID}/${IMAGE_NAME}/${IMAGE_NAME}:latest")
      export DOCKER_IMAGE=${IMAGE_FULL}
      export GCP_SERVICE_ACCOUNT_KEY=${GCP_SERVICE_ACCOUNT_KEY:-}
      chmod +x tests/security-scan.sh
      tests/security-scan.sh
  dependencies:
    - docker:build
  artifacts:
    reports:
      sast: trivy-report.json
    paths:
      - trivy-report.json
    expire_in: 1 week
  only:
    - main
    - master
    - develop
  allow_failure: true
  # Security scans are important but shouldn't block deployment for warnings

# =============================================================================
# DEPLOY STAGE
# =============================================================================

deploy:ansible:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client ansible python3 py3-pip
    - python3 -m venv /tmp/venv
    - . /tmp/venv/bin/activate
    - pip install docker
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $VM_EXTERNAL_IP >> ~/.ssh/known_hosts
  script:
    - |
      export IMAGE_FULL=$(cat docker-image.txt || echo "${CONTAINER_REGISTRY}/${GCP_PROJECT_ID}/${IMAGE_NAME}/${IMAGE_NAME}:latest")
      echo "Deploying image: ${IMAGE_FULL}"
      cat > ansible/inventory/hosts.yml <<EOF
      all:
        hosts:
          automation-alchemy:
            ansible_host: ${VM_EXTERNAL_IP}
            ansible_user: devops
            ansible_ssh_private_key_file: ~/.ssh/id_rsa
            docker_image: ${IMAGE_FULL}
      EOF
      cd ansible
      ansible-playbook playbooks/site.yml -i inventory/hosts.yml
  environment:
    name: production
    url: http://${VM_EXTERNAL_IP}:8080
  only:
    - main
    - master
  when: manual
  allow_failure: false

# =============================================================================
# HEALTHCHECK STAGE
# =============================================================================

healthcheck:application:
  stage: healthcheck
  image: curlimages/curl:latest
  script:
    - |
      echo "Checking application health..."
      HEALTH_URL="http://${VM_EXTERNAL_IP}:8080"
      echo "Testing load balancer: ${HEALTH_URL}"
      curl -f -s -o /dev/null -w "HTTP Status: %{http_code}\n" ${HEALTH_URL} || exit 1
      echo "Testing app server: http://${VM_EXTERNAL_IP}:3000/health"
      curl -f -s -o /dev/null -w "HTTP Status: %{http_code}\n" http://${VM_EXTERNAL_IP}:3000/health || exit 1
      echo "Testing web server 1: http://${VM_EXTERNAL_IP}:8081/health"
      curl -f -s -o /dev/null -w "HTTP Status: %{http_code}\n" http://${VM_EXTERNAL_IP}:8081/health || exit 1
      echo "Testing web server 2: http://${VM_EXTERNAL_IP}:8082/health"
      curl -f -s -o /dev/null -w "HTTP Status: %{http_code}\n" http://${VM_EXTERNAL_IP}:8082/health || exit 1
      echo "All health checks passed!"
  only:
    - main
    - master
  dependencies:
    - deploy:ansible

# =============================================================================
# INTEGRATION STAGE (Phase 4: Integration & Performance Tests)
# =============================================================================

test:integration:
  stage: integration
  image: alpine:latest
  before_script:
    - apk add --no-cache bash curl
  script:
    - |
      export BASE_URL="http://${VM_EXTERNAL_IP}:8080"
      export VM_IP="${VM_EXTERNAL_IP}"
      chmod +x tests/integration-test.sh
      tests/integration-test.sh
  dependencies:
    - deploy:ansible
  only:
    - main
    - master
  when: manual
  allow_failure: false

test:performance:
  stage: integration
  image: alpine:latest
  before_script:
    - apk add --no-cache bash curl apache2-utils bc
  script:
    - |
      export TARGET_URL="http://${VM_EXTERNAL_IP}:8080"
      export REQUESTS=50
      export CONCURRENCY=5
      export MAX_RESPONSE_TIME=1000
      chmod +x tests/performance-test.sh
      tests/performance-test.sh
  dependencies:
    - deploy:ansible
  only:
    - main
    - master
  when: manual
  allow_failure: true
  # Performance tests are informative but shouldn't block deployment

